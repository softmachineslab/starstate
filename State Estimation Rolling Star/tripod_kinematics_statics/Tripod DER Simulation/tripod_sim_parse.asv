function [vertex_xy,feet_data,limbs_data] = tripod_sim_parse(simdata,time)
% tripod_sim_parse inputs the data from a tripod DER simulation and a
% simulation time. The function parses the simulation data into useful
% vectors and data structures
%
%   Inputs:
%
%   simdata = simulation data from cvs file.
%
%   time = point in simulation where we want to inspect the robot
% 
%   Outputs:
%
%   vertex_xy = 2 row matrix with all the x and y coordinates of all the
%   verticies (x in row 1, y in row 2)
%
%   feet_data = struct with 2x2 matricies of x and y coordinates of the feet 
%
%   limbs_data = struct with 13 or 14x2 matricies with the xy verteixes of the
%   stright section of the arms
%
%   curve_tips = tips of curved sections from simulation data (2x7 matrix)
%
%   tips = tips of stright sections from simulation data (2x7 matrix)
%

% calulcate the row of the spreadsheet that is closest to the time input
row = round(200*time)+1;
simdata = simdata(row,:);

% Hard-code some of the simulation parameters from the text file.
num_limbs = 3;  % number of limbs
num_feet = 2;   % number of feet
num_v_per_limb = 13; % number of vertices per "circular part" of a limb
num_v_per_foot = 2; % number of vertices per "flat part" of a limb.
% ...note that total number of vertices, i.e. columns in vertex_x or vertex_y, is:
% num_limbs * (num_v_per_limb + num_v_per_flat).

%create a matrix excluding time stamp data
vertex_all_data = simdata(2:end);

% The vertex coordinates are stored as [x1, y1, x2, y2, .... xN, yN], but
% we'll need to separate out the x and y values. Take every other column:
vertex_x = vertex_all_data(1:2:end);
vertex_y = vertex_all_data(2:2:end);

vertex_xy = [vertex_x;vertex_y];

%Need all 14 xy coordinate pairs for each of the separate limbs, create a
%data structure where each each field is a matrix of the xy coordiates of
%the limb.  i.e. curve_data{1} will be a (num_v_per_circ x 2) matrix with 
%the x coordiates in column 1 and the y coordinates in column 2.  Note,
%each curved section originally has 13 vertexes, but we will add the
%previous tip as the first entry
limbs_x = vertex_x(1:(num_limbs * num_v_per_limb+1)); %x-coordinates for the curved sections
limbs_y = vertex_y(1:(num_limbs * num_v_per_limb+1)); %y-coordinates for the curved sections


feet_x = vertex_x((num_limbs * num_v_per_limb)+2:end);
feet_y = vertex_y((num_limbs * num_v_per_limb)+2:end);


%create data structure for curved sections
for i = 1:num_limbs    
    if i == 3
        limb_x_vec = limbs_x((i-1)*num_v_per_limb+1:(i)*num_v_per_limb+1);
        limb_y_vec = limbs_y((i-1)*num_v_per_limb+1:(i)*num_v_per_limb+1);
    else
        limb_x_vec = limbs_x((i-1)*num_v_per_limb+1:(i)*num_v_per_limb);
        limb_y_vec = limbs_y((i-1)*num_v_per_limb+1:(i)*num_v_per_limb);
    end    
    %create data structure of x and y coordinates for each limb
    limbs_data{i} = [limb_x_vec; limb_y_vec];
end
% limbs_data_switch = limbs_data{3};
% limbs_data{3}=limbs_data{1};
% limbs_data{1} = limbs_data_switch;

for i = 1:num_feet
    foot_x_vec = feet_x((i-1)*num_v_per_foot+1:(i)*num_v_per_foot); %x-coordinates for the curved sections
    foot_y_vec = feet_y((i-1)*num_v_per_foot+1:(i)*num_v_per_foot); %y-coordinates for the curved sections
    feet_data{i} = [foot_x_vec; foot_y_vec];
end
% feet_data_switch = feet_data{2};
% feet_data{2}=feet_data{1};
% feet_data{1} = feet_data_switch;
%create data structure for stright sections
% for i = 1:num_limbs
%     foot_x = feet_x((i-1)*num_v_per_foot+1:(i*num_v_per_foot));
%     foot_y = feet_y((i-1)*num_v_per_foot+1:(i*num_v_per_foot));   
%     foot_x = [limb_data{i}(1,1), foot_x];
%     foot_y = [limb_data{i}(2,1), foot_y]; 
%     foot_data{i} = [foot_x; foot_y];
% end

%create vectors of the x and y cooridates of the tips of the robot.  The
%tips occur as the num_v_per_circ 'th row of the curve data matricies. 
% for k = 1:num_limbs
%     curve_tips_x(k) = limb_data{k}(1,1);
%     curve_tips_y(k) = limb_data{k}(2,1);
% end
% %create a matrix of tip locations col 1 = tips_x, col 2 = tips_y
% curve_tips = [curve_tips_x; curve_tips_y];
% 
% %calculate the xy coordinates of the true tips of the robot
% for i = 1:num_limbs
%     tips_x(i) = straight_data{i}(1,num_v_per_flat+1);
%     tips_y(i) = straight_data{i}(2,num_v_per_flat+1);
% end
% tips = [tips_x;tips_y];
% 
% tips(1,:) = [tips(1,2:7), tips(1,1)];
% tips(2,:) = [tips(2,2:7), tips(2,1)];
% end
